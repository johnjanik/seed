//! Text rendering support for the software renderer.
//!
//! This module provides text rasterization using a built-in bitmap font.

use seed_core::types::Color;

/// Built-in 8x8 bitmap font for basic ASCII characters (32-126).
/// Each character is represented as 8 bytes, where each byte is a row of 8 pixels.
static FONT_8X8: &[u8] = &[
    // Space (32)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ! (33)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00,
    // " (34)
    0x6C, 0x6C, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    // # (35)
    0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00,
    // $ (36)
    0x18, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x18, 0x00,
    // % (37)
    0x00, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xC6, 0x00,
    // & (38)
    0x38, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0x76, 0x00,
    // ' (39)
    0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    // ( (40)
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // ) (41)
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // * (42)
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // + (43)
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // , (44)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // - (45)
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // . (46)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // / (47)
    0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00,
    // 0 (48)
    0x7C, 0xCE, 0xDE, 0xF6, 0xE6, 0xC6, 0x7C, 0x00,
    // 1 (49)
    0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // 2 (50)
    0x7C, 0xC6, 0x0E, 0x3C, 0x78, 0xE0, 0xFE, 0x00,
    // 3 (51)
    0x7E, 0x0C, 0x18, 0x3C, 0x06, 0xC6, 0x7C, 0x00,
    // 4 (52)
    0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x00,
    // 5 (53)
    0xFE, 0xC0, 0xFC, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // 6 (54)
    0x3C, 0x60, 0xC0, 0xFC, 0xC6, 0xC6, 0x7C, 0x00,
    // 7 (55)
    0xFE, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00,
    // 8 (56)
    0x7C, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0x7C, 0x00,
    // 9 (57)
    0x7C, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00,
    // : (58)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x00,
    // ; (59)
    0x00, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // < (60)
    0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00,
    // = (61)
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // > (62)
    0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00,
    // ? (63)
    0x7C, 0xC6, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00,
    // @ (64)
    0x7C, 0xC6, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00,
    // A (65)
    0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x00,
    // B (66)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0x00,
    // C (67)
    0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00,
    // D (68)
    0xF8, 0xCC, 0xC6, 0xC6, 0xC6, 0xCC, 0xF8, 0x00,
    // E (69)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xFE, 0x00,
    // F (70)
    0xFE, 0xC0, 0xC0, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // G (71)
    0x7C, 0xC6, 0xC0, 0xCE, 0xC6, 0xC6, 0x7E, 0x00,
    // H (72)
    0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00,
    // I (73)
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // J (74)
    0x06, 0x06, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00,
    // K (75)
    0xC6, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0xC6, 0x00,
    // L (76)
    0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00,
    // M (77)
    0xC6, 0xEE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0x00,
    // N (78)
    0xC6, 0xE6, 0xF6, 0xDE, 0xCE, 0xC6, 0xC6, 0x00,
    // O (79)
    0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // P (80)
    0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00,
    // Q (81)
    0x7C, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x06,
    // R (82)
    0xFC, 0xC6, 0xC6, 0xFC, 0xD8, 0xCC, 0xC6, 0x00,
    // S (83)
    0x7C, 0xC6, 0xC0, 0x7C, 0x06, 0xC6, 0x7C, 0x00,
    // T (84)
    0xFE, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // U (85)
    0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // V (86)
    0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00,
    // W (87)
    0xC6, 0xC6, 0xC6, 0xD6, 0xFE, 0xEE, 0xC6, 0x00,
    // X (88)
    0xC6, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0xC6, 0x00,
    // Y (89)
    0xC6, 0xC6, 0x6C, 0x38, 0x18, 0x18, 0x18, 0x00,
    // Z (90)
    0xFE, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xFE, 0x00,
    // [ (91)
    0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00,
    // \ (92)
    0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00,
    // ] (93)
    0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00,
    // ^ (94)
    0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00,
    // _ (95)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF,
    // ` (96)
    0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00,
    // a (97)
    0x00, 0x00, 0x7C, 0x06, 0x7E, 0xC6, 0x7E, 0x00,
    // b (98)
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xFC, 0x00,
    // c (99)
    0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC6, 0x7C, 0x00,
    // d (100)
    0x06, 0x06, 0x7E, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // e (101)
    0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0x7C, 0x00,
    // f (102)
    0x1C, 0x36, 0x30, 0x78, 0x30, 0x30, 0x30, 0x00,
    // g (103)
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // h (104)
    0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // i (105)
    0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // j (106)
    0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0xCC, 0x78,
    // k (107)
    0xC0, 0xC0, 0xCC, 0xD8, 0xF0, 0xD8, 0xCC, 0x00,
    // l (108)
    0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // m (109)
    0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xC6, 0xC6, 0x00,
    // n (110)
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x00,
    // o (111)
    0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0x00,
    // p (112)
    0x00, 0x00, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0,
    // q (113)
    0x00, 0x00, 0x7E, 0xC6, 0xC6, 0x7E, 0x06, 0x06,
    // r (114)
    0x00, 0x00, 0xDC, 0xE6, 0xC0, 0xC0, 0xC0, 0x00,
    // s (115)
    0x00, 0x00, 0x7E, 0xC0, 0x7C, 0x06, 0xFC, 0x00,
    // t (116)
    0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00,
    // u (117)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x00,
    // v (118)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00,
    // w (119)
    0x00, 0x00, 0xC6, 0xC6, 0xD6, 0xFE, 0x6C, 0x00,
    // x (120)
    0x00, 0x00, 0xC6, 0x6C, 0x38, 0x6C, 0xC6, 0x00,
    // y (121)
    0x00, 0x00, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x7C,
    // z (122)
    0x00, 0x00, 0xFE, 0x0C, 0x38, 0x60, 0xFE, 0x00,
    // { (123)
    0x0E, 0x18, 0x18, 0x70, 0x18, 0x18, 0x0E, 0x00,
    // | (124)
    0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // } (125)
    0x70, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x70, 0x00,
    // ~ (126)
    0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
];

/// Text renderer using built-in bitmap font.
pub struct TextRenderer {
    /// Base character size (8x8 pixels)
    char_width: u32,
    char_height: u32,
}

impl TextRenderer {
    /// Create a new text renderer with the built-in font.
    pub fn new() -> Self {
        Self {
            char_width: 8,
            char_height: 8,
        }
    }

    /// Rasterize text and return (bitmap, width, height).
    /// The bitmap is a single-channel alpha mask.
    pub fn rasterize(&self, text: &str, font_size: f32) -> (Vec<u8>, u32, u32) {
        if text.is_empty() {
            return (vec![], 0, 0);
        }

        // Calculate scale factor
        let scale = (font_size / 8.0).max(1.0);
        let scaled_width = (self.char_width as f32 * scale).ceil() as u32;
        let scaled_height = (self.char_height as f32 * scale).ceil() as u32;

        // Calculate total dimensions
        let char_count = text.chars().count() as u32;
        let total_width = char_count * scaled_width;
        let total_height = scaled_height;

        let mut bitmap = vec![0u8; (total_width * total_height) as usize];

        // Render each character
        for (i, ch) in text.chars().enumerate() {
            let x_offset = i as u32 * scaled_width;
            self.render_char(&mut bitmap, total_width, ch, x_offset, 0, scale);
        }

        (bitmap, total_width, total_height)
    }

    /// Render a single character to the bitmap.
    fn render_char(&self, bitmap: &mut [u8], stride: u32, ch: char, x: u32, y: u32, scale: f32) {
        let code = ch as u32;
        if code < 32 || code > 126 {
            return; // Skip unsupported characters
        }

        let glyph_index = (code - 32) as usize;
        let glyph_offset = glyph_index * 8;

        if glyph_offset + 8 > FONT_8X8.len() {
            return;
        }

        let scaled_width = (self.char_width as f32 * scale).ceil() as u32;
        let scaled_height = (self.char_height as f32 * scale).ceil() as u32;

        // Scale the glyph using nearest-neighbor sampling
        for sy in 0..scaled_height {
            for sx in 0..scaled_width {
                // Map scaled position back to original 8x8 grid
                let orig_x = ((sx as f32 / scale) as u32).min(7);
                let orig_y = ((sy as f32 / scale) as u32).min(7);

                let row = FONT_8X8[glyph_offset + orig_y as usize];
                let bit = (row >> (7 - orig_x)) & 1;

                if bit == 1 {
                    let px = x + sx;
                    let py = y + sy;
                    let idx = (py * stride + px) as usize;
                    if idx < bitmap.len() {
                        bitmap[idx] = 255;
                    }
                }
            }
        }
    }

    /// Measure text and return (width, height).
    pub fn measure(&self, text: &str, font_size: f32) -> (f32, f32) {
        if text.is_empty() {
            return (0.0, font_size);
        }

        let scale = (font_size / 8.0).max(1.0);
        let scaled_width = self.char_width as f32 * scale;
        let scaled_height = self.char_height as f32 * scale;

        let width = text.chars().count() as f32 * scaled_width;
        (width, scaled_height)
    }
}

impl Default for TextRenderer {
    fn default() -> Self {
        Self::new()
    }
}

/// Blend text bitmap onto an RGBA buffer.
pub fn blend_text_onto_buffer(
    buffer: &mut [u8],
    buffer_width: u32,
    buffer_height: u32,
    text_bitmap: &[u8],
    text_width: u32,
    text_height: u32,
    x: i32,
    y: i32,
    color: Color,
) {
    let (tr, tg, tb, _ta) = color.to_rgba8();

    for ty in 0..text_height {
        for tx in 0..text_width {
            let px = x + tx as i32;
            let py = y + ty as i32;

            if px < 0 || py < 0 || px >= buffer_width as i32 || py >= buffer_height as i32 {
                continue;
            }

            let text_idx = (ty * text_width + tx) as usize;
            let coverage = text_bitmap.get(text_idx).copied().unwrap_or(0);

            if coverage == 0 {
                continue;
            }

            let alpha = coverage as f32 / 255.0;
            let buffer_idx = ((py as u32 * buffer_width + px as u32) * 4) as usize;

            if buffer_idx + 3 >= buffer.len() {
                continue;
            }

            // Alpha blend
            let dst_r = buffer[buffer_idx] as f32 / 255.0;
            let dst_g = buffer[buffer_idx + 1] as f32 / 255.0;
            let dst_b = buffer[buffer_idx + 2] as f32 / 255.0;

            let src_r = tr as f32 / 255.0;
            let src_g = tg as f32 / 255.0;
            let src_b = tb as f32 / 255.0;

            buffer[buffer_idx] = ((src_r * alpha + dst_r * (1.0 - alpha)) * 255.0) as u8;
            buffer[buffer_idx + 1] = ((src_g * alpha + dst_g * (1.0 - alpha)) * 255.0) as u8;
            buffer[buffer_idx + 2] = ((src_b * alpha + dst_b * (1.0 - alpha)) * 255.0) as u8;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_text_renderer_creation() {
        let _renderer = TextRenderer::new();
    }

    #[test]
    fn test_text_measurement() {
        let renderer = TextRenderer::new();
        let (width, height) = renderer.measure("Hello", 16.0);
        // 5 chars * 16 pixels = 80 width
        assert_eq!(width, 80.0);
        assert_eq!(height, 16.0);
    }

    #[test]
    fn test_text_rasterization() {
        let renderer = TextRenderer::new();
        let (bitmap, width, height) = renderer.rasterize("AB", 8.0);
        assert_eq!(width, 16); // 2 chars * 8 pixels
        assert_eq!(height, 8);
        assert!(!bitmap.is_empty());
        // Check that some pixels are set (A and B have visible pixels)
        assert!(bitmap.iter().any(|&p| p > 0));
    }

    #[test]
    fn test_blend_text_onto_buffer() {
        let mut buffer = vec![255u8; 100 * 100 * 4]; // White background
        let text_bitmap = vec![255u8; 10 * 10]; // Full coverage text

        blend_text_onto_buffer(
            &mut buffer,
            100, 100,
            &text_bitmap,
            10, 10,
            5, 5,
            Color::rgb(0.0, 0.0, 0.0), // Black text
        );

        // Check that the text area is now black
        let idx = ((5 * 100 + 5) * 4) as usize;
        assert_eq!(buffer[idx], 0); // R
        assert_eq!(buffer[idx + 1], 0); // G
        assert_eq!(buffer[idx + 2], 0); // B
    }

    #[test]
    fn test_empty_text() {
        let renderer = TextRenderer::new();
        let (bitmap, width, height) = renderer.rasterize("", 16.0);
        assert!(bitmap.is_empty());
        assert_eq!(width, 0);
        assert_eq!(height, 0);
    }

    #[test]
    fn test_scaled_text() {
        let renderer = TextRenderer::new();
        let (bitmap, width, height) = renderer.rasterize("A", 16.0);
        assert_eq!(width, 16); // Scaled from 8
        assert_eq!(height, 16);
        assert!(!bitmap.is_empty());
    }
}
