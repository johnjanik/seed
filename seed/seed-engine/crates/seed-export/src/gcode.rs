//! G-Code export for CNC and 3D printing.
//!
//! Generates G-Code toolpaths from 3D meshes by:
//! 1. Slicing the mesh at regular Z intervals
//! 2. Extracting contour paths from each slice
//! 3. Converting paths to G-Code move commands

use seed_core::{Document, ExportError, ast::Element};
use seed_render_3d::{create_shape, Mesh, TessellationOptions};
use glam::Vec3;
use std::fmt::Write;

/// G-Code export options.
#[derive(Debug, Clone)]
pub struct GCodeOptions {
    /// Machine type (affects G-Code flavor).
    pub machine: MachineType,
    /// Layer height in mm (for 3D printing).
    pub layer_height: f64,
    /// Nozzle/tool diameter in mm.
    pub tool_diameter: f64,
    /// Print/feed speed in mm/min.
    pub feed_rate: f64,
    /// Travel speed in mm/min.
    pub travel_rate: f64,
    /// Extrusion multiplier (for 3D printing).
    pub extrusion_multiplier: f64,
    /// Filament diameter in mm (for 3D printing).
    pub filament_diameter: f64,
    /// Hotend temperature (for 3D printing).
    pub hotend_temp: Option<u16>,
    /// Bed temperature (for 3D printing).
    pub bed_temp: Option<u16>,
    /// Include comments in output.
    pub comments: bool,
    /// Tessellation options for mesh generation.
    pub tessellation: TessellationOptions,
}

impl Default for GCodeOptions {
    fn default() -> Self {
        Self {
            machine: MachineType::Marlin,
            layer_height: 0.2,
            tool_diameter: 0.4,
            feed_rate: 1800.0,  // 30 mm/s
            travel_rate: 3000.0, // 50 mm/s
            extrusion_multiplier: 1.0,
            filament_diameter: 1.75,
            hotend_temp: Some(200),
            bed_temp: Some(60),
            comments: true,
            tessellation: TessellationOptions::default(),
        }
    }
}

/// Machine/firmware type for G-Code flavor.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum MachineType {
    /// Marlin firmware (most 3D printers).
    Marlin,
    /// Grbl firmware (CNC machines).
    Grbl,
    /// RepRap firmware.
    RepRap,
    /// Generic G-Code (minimal commands).
    Generic,
}

/// Export a document to G-Code.
pub fn export(doc: &Document) -> Result<String, ExportError> {
    export_with_options(doc, &GCodeOptions::default())
}

/// Export a document to G-Code with custom options.
pub fn export_with_options(doc: &Document, options: &GCodeOptions) -> Result<String, ExportError> {
    // Collect all meshes from Part elements
    let mut combined_mesh = Mesh::new();

    for element in &doc.elements {
        if let Element::Part(part) = element {
            let shape = create_shape(&part.geometry)
                .map_err(|e| ExportError::GeometryError { reason: e.to_string() })?;
            let mut mesh = seed_render_3d::tessellate_with_options(&shape, &options.tessellation);
            mesh.transform(shape.transform());
            combined_mesh.merge(&mesh);
        }
    }

    if combined_mesh.triangle_count() == 0 {
        return Err(ExportError::NoGeometry);
    }

    let mut builder = GCodeBuilder::new(options);
    builder.generate(&combined_mesh)?;
    Ok(builder.finish())
}

/// Builder for G-Code output.
struct GCodeBuilder<'a> {
    options: &'a GCodeOptions,
    output: String,
    current_z: f64,
    current_e: f64, // Extruder position
    current_x: f64,
    current_y: f64,
}

impl<'a> GCodeBuilder<'a> {
    fn new(options: &'a GCodeOptions) -> Self {
        Self {
            options,
            output: String::new(),
            current_z: 0.0,
            current_e: 0.0,
            current_x: 0.0,
            current_y: 0.0,
        }
    }

    fn generate(&mut self, mesh: &Mesh) -> Result<(), ExportError> {
        // Find mesh bounds
        let bounds = mesh.bounding_box()
            .ok_or(ExportError::NoGeometry)?;

        let min_z = bounds.min.z as f64;
        let max_z = bounds.max.z as f64;

        // Write header
        self.write_header(&bounds);

        // Slice and generate paths for each layer
        let mut z = min_z + self.options.layer_height;
        let mut layer_num = 0;

        while z <= max_z {
            let contours = slice_mesh_at_z(mesh, z as f32);

            if !contours.is_empty() {
                self.write_layer(layer_num, z, &contours);
                layer_num += 1;
            }

            z += self.options.layer_height;
        }

        // Write footer
        self.write_footer();

        Ok(())
    }

    fn write_header(&mut self, bounds: &seed_render_3d::BoundingBox) {
        if self.options.comments {
            writeln!(self.output, "; Generated by Seed Engine").unwrap();
            writeln!(self.output, "; Bounds: ({:.2}, {:.2}, {:.2}) to ({:.2}, {:.2}, {:.2})",
                bounds.min.x, bounds.min.y, bounds.min.z,
                bounds.max.x, bounds.max.y, bounds.max.z).unwrap();
            writeln!(self.output, "; Layer height: {:.2} mm", self.options.layer_height).unwrap();
            writeln!(self.output).unwrap();
        }

        match self.options.machine {
            MachineType::Marlin | MachineType::RepRap => {
                // Start G-Code for 3D printing
                writeln!(self.output, "G21 ; Set units to millimeters").unwrap();
                writeln!(self.output, "G90 ; Absolute positioning").unwrap();
                writeln!(self.output, "M82 ; Absolute extrusion").unwrap();

                if let Some(bed_temp) = self.options.bed_temp {
                    writeln!(self.output, "M140 S{} ; Set bed temperature", bed_temp).unwrap();
                }
                if let Some(hotend_temp) = self.options.hotend_temp {
                    writeln!(self.output, "M104 S{} ; Set hotend temperature", hotend_temp).unwrap();
                }
                if self.options.bed_temp.is_some() {
                    writeln!(self.output, "M190 S{} ; Wait for bed", self.options.bed_temp.unwrap()).unwrap();
                }
                if self.options.hotend_temp.is_some() {
                    writeln!(self.output, "M109 S{} ; Wait for hotend", self.options.hotend_temp.unwrap()).unwrap();
                }

                writeln!(self.output, "G28 ; Home all axes").unwrap();
                writeln!(self.output, "G92 E0 ; Reset extruder").unwrap();
                writeln!(self.output).unwrap();
            }
            MachineType::Grbl => {
                // Start G-Code for CNC
                writeln!(self.output, "G21 ; Millimeters").unwrap();
                writeln!(self.output, "G90 ; Absolute positioning").unwrap();
                writeln!(self.output, "G17 ; XY plane").unwrap();
                writeln!(self.output, "M3 S1000 ; Spindle on").unwrap();
                writeln!(self.output).unwrap();
            }
            MachineType::Generic => {
                writeln!(self.output, "G21").unwrap();
                writeln!(self.output, "G90").unwrap();
                writeln!(self.output).unwrap();
            }
        }
    }

    fn write_footer(&mut self) {
        if self.options.comments {
            writeln!(self.output).unwrap();
            writeln!(self.output, "; End G-Code").unwrap();
        }

        match self.options.machine {
            MachineType::Marlin | MachineType::RepRap => {
                writeln!(self.output, "M104 S0 ; Turn off hotend").unwrap();
                writeln!(self.output, "M140 S0 ; Turn off bed").unwrap();
                writeln!(self.output, "G91 ; Relative positioning").unwrap();
                writeln!(self.output, "G1 Z10 F3000 ; Raise Z").unwrap();
                writeln!(self.output, "G90 ; Absolute positioning").unwrap();
                writeln!(self.output, "G1 X0 Y200 F3000 ; Move to front").unwrap();
                writeln!(self.output, "M84 ; Disable steppers").unwrap();
            }
            MachineType::Grbl => {
                writeln!(self.output, "M5 ; Spindle off").unwrap();
                writeln!(self.output, "G0 Z10 ; Raise Z").unwrap();
                writeln!(self.output, "G0 X0 Y0 ; Return to origin").unwrap();
                writeln!(self.output, "M30 ; Program end").unwrap();
            }
            MachineType::Generic => {
                writeln!(self.output, "M2 ; Program end").unwrap();
            }
        }
    }

    fn write_layer(&mut self, layer_num: usize, z: f64, contours: &[Contour]) {
        if self.options.comments {
            writeln!(self.output, "; Layer {} at Z={:.3}", layer_num, z).unwrap();
        }

        // Move to layer Z
        if (z - self.current_z).abs() > 0.001 {
            writeln!(self.output, "G0 Z{:.3} F{:.0}", z, self.options.travel_rate).unwrap();
            self.current_z = z;
        }

        for contour in contours {
            if contour.points.is_empty() {
                continue;
            }

            // Travel to start of contour
            let start = &contour.points[0];
            writeln!(self.output, "G0 X{:.3} Y{:.3} F{:.0}",
                start.0, start.1, self.options.travel_rate).unwrap();
            self.current_x = start.0;
            self.current_y = start.1;

            // Extrude along contour
            for point in contour.points.iter().skip(1) {
                let distance = ((point.0 - self.current_x).powi(2) +
                               (point.1 - self.current_y).powi(2)).sqrt();

                if self.options.machine == MachineType::Marlin ||
                   self.options.machine == MachineType::RepRap {
                    // Calculate extrusion
                    let extrusion = self.calculate_extrusion(distance);
                    self.current_e += extrusion;
                    writeln!(self.output, "G1 X{:.3} Y{:.3} E{:.4} F{:.0}",
                        point.0, point.1, self.current_e, self.options.feed_rate).unwrap();
                } else {
                    // CNC - just move
                    writeln!(self.output, "G1 X{:.3} Y{:.3} F{:.0}",
                        point.0, point.1, self.options.feed_rate).unwrap();
                }

                self.current_x = point.0;
                self.current_y = point.1;
            }

            // Close the contour if it's a loop
            if contour.closed && contour.points.len() > 2 {
                let start = &contour.points[0];
                let distance = ((start.0 - self.current_x).powi(2) +
                               (start.1 - self.current_y).powi(2)).sqrt();

                if distance > 0.01 {
                    if self.options.machine == MachineType::Marlin ||
                       self.options.machine == MachineType::RepRap {
                        let extrusion = self.calculate_extrusion(distance);
                        self.current_e += extrusion;
                        writeln!(self.output, "G1 X{:.3} Y{:.3} E{:.4} F{:.0}",
                            start.0, start.1, self.current_e, self.options.feed_rate).unwrap();
                    } else {
                        writeln!(self.output, "G1 X{:.3} Y{:.3} F{:.0}",
                            start.0, start.1, self.options.feed_rate).unwrap();
                    }
                }
            }
        }

        writeln!(self.output).unwrap();
    }

    fn calculate_extrusion(&self, distance: f64) -> f64 {
        // Volume = cross-sectional area × distance
        // Cross-section ≈ layer_height × tool_diameter (simplified)
        let cross_section = self.options.layer_height * self.options.tool_diameter;
        let volume = cross_section * distance;

        // Convert volume to filament length
        let filament_area = std::f64::consts::PI *
            (self.options.filament_diameter / 2.0).powi(2);
        let extrusion = volume / filament_area * self.options.extrusion_multiplier;

        extrusion
    }

    fn finish(self) -> String {
        self.output
    }
}

/// A contour (closed or open path) from mesh slicing.
#[derive(Debug, Clone)]
struct Contour {
    points: Vec<(f64, f64)>,
    closed: bool,
}

/// Slice a mesh at a given Z height and extract contours.
fn slice_mesh_at_z(mesh: &Mesh, z: f32) -> Vec<Contour> {
    let mut segments: Vec<((f64, f64), (f64, f64))> = Vec::new();

    // Find all triangle-plane intersections
    for tri in mesh.indices.chunks(3) {
        if tri.len() < 3 {
            continue;
        }

        let v0 = mesh.vertices[tri[0] as usize];
        let v1 = mesh.vertices[tri[1] as usize];
        let v2 = mesh.vertices[tri[2] as usize];

        // Find intersection with Z plane
        if let Some(segment) = triangle_plane_intersection(v0, v1, v2, z) {
            segments.push(segment);
        }
    }

    if segments.is_empty() {
        return Vec::new();
    }

    // Connect segments into contours
    build_contours(segments)
}

/// Find intersection of a triangle with a horizontal plane at Z.
fn triangle_plane_intersection(
    v0: Vec3, v1: Vec3, v2: Vec3, z: f32
) -> Option<((f64, f64), (f64, f64))> {
    let edges = [(v0, v1), (v1, v2), (v2, v0)];
    let mut intersections: Vec<(f64, f64)> = Vec::new();

    for (a, b) in &edges {
        // Check if edge crosses the Z plane
        if (a.z <= z && b.z > z) || (a.z > z && b.z <= z) {
            // Linear interpolation to find intersection point
            let t = (z - a.z) / (b.z - a.z);
            let x = a.x + t * (b.x - a.x);
            let y = a.y + t * (b.y - a.y);
            intersections.push((x as f64, y as f64));
        } else if (a.z - z).abs() < 0.0001 && (b.z - z).abs() < 0.0001 {
            // Edge lies in the plane
            intersections.push((a.x as f64, a.y as f64));
            intersections.push((b.x as f64, b.y as f64));
        }
    }

    if intersections.len() >= 2 {
        Some((intersections[0], intersections[1]))
    } else {
        None
    }
}

/// Build contours from line segments by connecting them.
fn build_contours(mut segments: Vec<((f64, f64), (f64, f64))>) -> Vec<Contour> {
    let mut contours = Vec::new();
    let epsilon = 0.001;

    while !segments.is_empty() {
        let mut contour_points = Vec::new();
        let (start, end) = segments.remove(0);
        contour_points.push(start);
        contour_points.push(end);

        let mut current_end = end;
        let mut found = true;

        while found {
            found = false;

            for i in 0..segments.len() {
                let (s_start, s_end) = segments[i];

                // Check if this segment connects to current end
                let dist_to_start = ((s_start.0 - current_end.0).powi(2) +
                                     (s_start.1 - current_end.1).powi(2)).sqrt();
                let dist_to_end = ((s_end.0 - current_end.0).powi(2) +
                                   (s_end.1 - current_end.1).powi(2)).sqrt();

                if dist_to_start < epsilon {
                    contour_points.push(s_end);
                    current_end = s_end;
                    segments.remove(i);
                    found = true;
                    break;
                } else if dist_to_end < epsilon {
                    contour_points.push(s_start);
                    current_end = s_start;
                    segments.remove(i);
                    found = true;
                    break;
                }
            }
        }

        // Check if contour is closed
        let start = contour_points[0];
        let end = contour_points.last().unwrap();
        let closed = ((start.0 - end.0).powi(2) + (start.1 - end.1).powi(2)).sqrt() < epsilon;

        contours.push(Contour {
            points: contour_points,
            closed,
        });
    }

    contours
}

#[cfg(test)]
mod tests {
    use super::*;
    use seed_core::ast::{Document, Element, PartElement, Span};
    use seed_core::{Geometry, Primitive};
    use seed_core::types::{Length, Identifier};

    #[test]
    fn test_gcode_options_default() {
        let opts = GCodeOptions::default();
        assert_eq!(opts.machine, MachineType::Marlin);
        assert!((opts.layer_height - 0.2).abs() < 0.001);
        assert!((opts.tool_diameter - 0.4).abs() < 0.001);
    }

    #[test]
    fn test_export_empty_doc() {
        let doc = Document {
            meta: None,
            tokens: None,
            elements: vec![],
            span: Span::default(),
        };

        let result = export(&doc);
        assert!(matches!(result, Err(ExportError::NoGeometry)));
    }

    #[test]
    fn test_export_box() {
        let doc = Document {
            meta: None,
            tokens: None,
            elements: vec![
                Element::Part(PartElement {
                    name: Some(Identifier("TestBox".to_string())),
                    geometry: Geometry::Primitive(Primitive::Box {
                        width: Length::mm(10.0),
                        height: Length::mm(10.0),
                        depth: Length::mm(5.0),
                    }),
                    properties: vec![],
                    constraints: vec![],
                    span: Span::default(),
                }),
            ],
            span: Span::default(),
        };

        let result = export(&doc);
        assert!(result.is_ok());

        let gcode = result.unwrap();
        assert!(gcode.contains("G21")); // Millimeters
        assert!(gcode.contains("G90")); // Absolute positioning
        assert!(gcode.contains("G1")); // Linear moves
    }

    #[test]
    fn test_export_with_options() {
        let doc = Document {
            meta: None,
            tokens: None,
            elements: vec![
                Element::Part(PartElement {
                    name: None,
                    geometry: Geometry::Primitive(Primitive::Cylinder {
                        radius: Length::mm(5.0),
                        height: Length::mm(10.0),
                    }),
                    properties: vec![],
                    constraints: vec![],
                    span: Span::default(),
                }),
            ],
            span: Span::default(),
        };

        let options = GCodeOptions {
            machine: MachineType::Grbl,
            layer_height: 0.5,
            comments: true,
            ..Default::default()
        };

        let result = export_with_options(&doc, &options);
        assert!(result.is_ok());

        let gcode = result.unwrap();
        assert!(gcode.contains("M3")); // Spindle on (Grbl)
        assert!(gcode.contains("; Layer")); // Comments enabled
    }

    #[test]
    fn test_machine_types() {
        assert_eq!(MachineType::Marlin, MachineType::Marlin);
        assert_ne!(MachineType::Marlin, MachineType::Grbl);
    }

    #[test]
    fn test_triangle_plane_intersection() {
        // Triangle that crosses Z=0
        let v0 = Vec3::new(0.0, 0.0, -1.0);
        let v1 = Vec3::new(1.0, 0.0, 1.0);
        let v2 = Vec3::new(0.0, 1.0, 1.0);

        let result = triangle_plane_intersection(v0, v1, v2, 0.0);
        assert!(result.is_some());
    }

    #[test]
    fn test_triangle_no_intersection() {
        // Triangle entirely above Z=0
        let v0 = Vec3::new(0.0, 0.0, 1.0);
        let v1 = Vec3::new(1.0, 0.0, 2.0);
        let v2 = Vec3::new(0.0, 1.0, 3.0);

        let result = triangle_plane_intersection(v0, v1, v2, 0.0);
        assert!(result.is_none());
    }

    #[test]
    fn test_build_contours() {
        // Two connected segments forming a path
        let segments = vec![
            ((0.0, 0.0), (1.0, 0.0)),
            ((1.0, 0.0), (1.0, 1.0)),
        ];

        let contours = build_contours(segments);
        assert_eq!(contours.len(), 1);
        assert_eq!(contours[0].points.len(), 3);
    }

    #[test]
    fn test_extrusion_calculation() {
        let options = GCodeOptions::default();
        let builder = GCodeBuilder::new(&options);

        // For 10mm travel with default settings
        let extrusion = builder.calculate_extrusion(10.0);

        // Should be positive and reasonable
        assert!(extrusion > 0.0);
        assert!(extrusion < 1.0); // Typically much less than travel distance
    }

    #[test]
    fn test_gcode_header_marlin() {
        let doc = Document {
            meta: None,
            tokens: None,
            elements: vec![
                Element::Part(PartElement {
                    name: None,
                    geometry: Geometry::Primitive(Primitive::Box {
                        width: Length::mm(10.0),
                        height: Length::mm(10.0),
                        depth: Length::mm(10.0),
                    }),
                    properties: vec![],
                    constraints: vec![],
                    span: Span::default(),
                }),
            ],
            span: Span::default(),
        };

        let options = GCodeOptions {
            machine: MachineType::Marlin,
            hotend_temp: Some(210),
            bed_temp: Some(65),
            ..Default::default()
        };

        let gcode = export_with_options(&doc, &options).unwrap();
        assert!(gcode.contains("M104 S210")); // Set hotend
        assert!(gcode.contains("M140 S65")); // Set bed
        assert!(gcode.contains("G28")); // Home
    }

    #[test]
    fn test_gcode_footer() {
        let doc = Document {
            meta: None,
            tokens: None,
            elements: vec![
                Element::Part(PartElement {
                    name: None,
                    geometry: Geometry::Primitive(Primitive::Box {
                        width: Length::mm(5.0),
                        height: Length::mm(5.0),
                        depth: Length::mm(5.0),
                    }),
                    properties: vec![],
                    constraints: vec![],
                    span: Span::default(),
                }),
            ],
            span: Span::default(),
        };

        let gcode = export(&doc).unwrap();
        assert!(gcode.contains("M84")); // Disable steppers (Marlin footer)
    }
}
