<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Seed Engine Demo</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto auto 1fr;
            gap: 12px;
            padding: 12px;
            height: 100vh;
        }
        header {
            grid-column: 1 / -1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 4px 0;
        }
        h1 {
            font-size: 1.25rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        .status {
            font-size: 0.75rem;
            padding: 3px 10px;
            border-radius: 999px;
            background: #2d2d44;
        }
        .status.ready { background: #1e3a2f; color: #4ade80; }
        .status.error { background: #3a1e1e; color: #f87171; }

        /* Compact toolbar bar */
        .toolbar-bar {
            grid-column: 1 / -1;
            display: flex;
            gap: 12px;
            align-items: stretch;
            background: #16162a;
            border-radius: 8px;
            padding: 8px 12px;
        }
        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            border-right: 1px solid #2d2d44;
        }
        .toolbar-section:last-child { border-right: none; }
        .toolbar-section h3 {
            font-size: 0.65rem;
            color: #667eea;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }
        .drop-zone-compact {
            border: 1px dashed #3d3d54;
            border-radius: 4px;
            padding: 6px 12px;
            font-size: 0.7rem;
            color: #888;
            cursor: pointer;
            transition: border-color 0.2s, background 0.2s;
            white-space: nowrap;
        }
        .drop-zone-compact:hover, .drop-zone-compact.dragover {
            border-color: #667eea;
            background: rgba(102, 126, 234, 0.1);
        }
        .file-info-compact {
            display: none;
            font-size: 0.7rem;
            color: #ccc;
            gap: 8px;
            align-items: center;
        }
        .file-info-compact.visible { display: flex; }
        .format-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.6rem;
            text-transform: uppercase;
            font-weight: 600;
        }
        .format-seed { background: #2d5a3d; color: #4ade80; }
        .format-gltf { background: #3d4a5a; color: #60a5fa; }
        .format-step { background: #5a4a3d; color: #fbbf24; }
        .format-usd { background: #5a3d5a; color: #c084fc; }
        .stat-inline {
            display: flex;
            gap: 12px;
            font-size: 0.7rem;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .stat-item .value {
            color: #667eea;
            font-weight: 600;
        }
        .stat-item .label {
            color: #666;
        }
        .toolbar-section select {
            padding: 5px 8px;
            border: none;
            border-radius: 4px;
            background: #2d2d44;
            color: #ccc;
            font-size: 0.7rem;
        }
        .btn-compact {
            padding: 5px 12px;
            border: none;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        .btn-compact:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        .error-inline {
            color: #f87171;
            font-size: 0.65rem;
            display: none;
        }

        /* Main content panels */
        .panel {
            background: #16162a;
            border-radius: 8px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        .panel-source {
            grid-row: 3;
            grid-column: 1;
        }
        .panel-preview {
            grid-row: 3;
            grid-column: 2;
        }
        .panel-header {
            padding: 8px 12px;
            background: #1e1e3a;
            font-weight: 500;
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .panel-header-actions {
            display: flex;
            gap: 6px;
        }
        .btn-small {
            padding: 4px 10px;
            border: none;
            border-radius: 4px;
            font-size: 0.65rem;
            cursor: pointer;
            background: #2d2d44;
            color: #ccc;
        }
        .btn-small:hover { background: #3d3d54; }
        .btn-small.primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        #editor {
            flex: 1;
            width: 100%;
            padding: 12px;
            background: transparent;
            border: none;
            color: #e0e0e0;
            font-family: 'JetBrains Mono', 'Fira Code', Consolas, monospace;
            font-size: 13px;
            line-height: 1.5;
            resize: none;
            outline: none;
        }

        /* Preview tabs and views */
        .preview-tabs {
            display: flex;
            gap: 0;
            background: #1e1e3a;
        }
        .preview-tab {
            padding: 6px 12px;
            background: transparent;
            border: none;
            color: #666;
            font-size: 0.65rem;
            text-transform: uppercase;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .preview-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
        }
        .preview-tab:hover { color: #888; }
        .preview-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .preview-2d {
            flex: 1;
            min-height: 0;
        }
        .preview-container {
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 12px;
            background: #fff;
            overflow: auto;
        }
        #canvas { max-width: 100%; max-height: 100%; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .comparison-container {
            height: 100%;
            display: flex;
            align-items: stretch;
            overflow: hidden;
        }
        .comparison-pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 12px;
            background: #fff;
            overflow: auto;
        }
        .comparison-pane.reference { background: #f5f5f5; border-right: 1px solid #ddd; }
        .pane-label {
            font-size: 0.6rem;
            text-transform: uppercase;
            color: #999;
            margin-bottom: 6px;
        }
        #reference-img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .reference-placeholder {
            color: #999;
            font-size: 0.75rem;
            text-align: center;
            padding: 16px;
        }
        .comparison-slider {
            display: none;
            height: 100%;
            position: relative;
            overflow: hidden;
            background: #fff;
        }
        .comparison-slider.active { display: flex; }
        .slider-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        .slider-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 50%;
            height: 100%;
            overflow: hidden;
            border-right: 2px solid #667eea;
        }
        .slider-handle {
            position: absolute;
            top: 0;
            left: 50%;
            width: 4px;
            height: 100%;
            background: #667eea;
            cursor: ew-resize;
            transform: translateX(-50%);
        }
        .slider-handle::before {
            content: '◀ ▶';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #667eea;
            color: white;
            padding: 3px 6px;
            border-radius: 3px;
            font-size: 0.5rem;
            white-space: nowrap;
        }
        .diff-overlay {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        .diff-overlay.active { display: block; }
        .info-bar {
            padding: 6px 12px;
            background: #1e1e3a;
            font-size: 0.65rem;
            color: #666;
            display: flex;
            gap: 12px;
        }
        .error-message {
            padding: 8px 12px;
            background: #3a1e1e;
            color: #f87171;
            font-family: monospace;
            font-size: 0.7rem;
            display: none;
        }

        /* 3D Viewer */
        .viewer-3d {
            background: #0a0a15;
            border-top: 1px solid #2d2d44;
            display: none;
            flex-direction: column;
        }
        .viewer-3d.visible { display: flex; }
        .viewer-3d-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 10px;
            background: #1e1e3a;
        }
        .viewer-3d-header h3 {
            font-size: 0.65rem;
            color: #667eea;
            text-transform: uppercase;
            margin: 0;
        }
        .viewer-3d-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            font-size: 0.6rem;
            color: #888;
        }
        .viewer-3d-controls select {
            padding: 3px 6px;
            border: none;
            border-radius: 3px;
            background: #2d2d44;
            color: #ccc;
            font-size: 0.6rem;
        }
        .viewer-3d-canvas {
            flex: 1;
            min-height: 200px;
            display: block;
            cursor: grab;
        }
        .viewer-3d-canvas:active { cursor: grabbing; }
        .viewer-3d-info {
            padding: 4px 10px;
            background: #1e1e3a;
            font-size: 0.6rem;
            color: #666;
        }

        /* Hidden file inputs */
        input[type="file"] { display: none; }

        @media (max-width: 900px) {
            .container { grid-template-columns: 1fr; grid-template-rows: auto auto 1fr 1fr; }
            .panel-source { grid-row: 3; grid-column: 1; }
            .panel-preview { grid-row: 4; grid-column: 1; }
            .toolbar-bar { flex-wrap: wrap; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Seed Engine</h1>
            <span id="status" class="status">Loading...</span>
        </header>

        <!-- Compact Toolbar Bar -->
        <div class="toolbar-bar">
            <!-- Import Section -->
            <div class="toolbar-section">
                <h3>Import</h3>
                <div class="drop-zone-compact" id="drop-zone">Drop file or click</div>
                <div class="file-info-compact" id="file-info">
                    <span id="file-name">-</span>
                    <span id="file-format" class="format-badge">-</span>
                </div>
                <input type="file" id="file-input-3d" accept=".gltf,.glb,.step,.stp,.usda,.usdc,.usd,.seed">
            </div>

            <!-- Scene Info Section -->
            <div class="toolbar-section">
                <h3>Scene</h3>
                <div class="stat-inline" id="scene-stats">
                    <div class="stat-item"><span class="value" id="stat-nodes">-</span><span class="label">nodes</span></div>
                    <div class="stat-item"><span class="value" id="stat-geometries">-</span><span class="label">geom</span></div>
                    <div class="stat-item"><span class="value" id="stat-materials">-</span><span class="label">mat</span></div>
                </div>
            </div>

            <!-- Export Section -->
            <div class="toolbar-section">
                <h3>Export</h3>
                <select id="export-format">
                    <option value="">Format...</option>
                    <option value="seed">Seed</option>
                    <option value="gltf">glTF</option>
                    <option value="step">STEP</option>
                    <option value="usd">USD</option>
                </select>
                <button class="btn-compact" id="btn-convert" disabled>Download</button>
                <span class="error-inline" id="convert-error"></span>
            </div>
        </div>

        <!-- Source Panel (Left) -->
        <div class="panel panel-source">
            <div class="panel-header">
                <span>Source</span>
                <div class="panel-header-actions">
                    <select id="examples" class="btn-small">
                        <option value="">Examples...</option>
                        <option value="simple">Simple</option>
                        <option value="nested">Nested</option>
                        <option value="gradient">Gradient</option>
                    </select>
                    <button class="btn-small primary" id="btn-render">Render</button>
                    <button class="btn-small" id="btn-svg">SVG</button>
                    <button class="btn-small" id="btn-png">PNG</button>
                </div>
            </div>
            <textarea id="editor" spellcheck="false">Frame:
  width: 200px
  height: 100px
  fill: #4a90d9
  corner-radius: 8px</textarea>
        </div>

        <!-- Preview Panel (Right) -->
        <div class="panel panel-preview">
            <div class="panel-header">
                <span>Preview</span>
                <div class="panel-header-actions">
                    <button class="btn-small" id="btn-import">Import Ref</button>
                    <button class="btn-small" id="btn-clear-ref" style="display:none;">Clear</button>
                </div>
            </div>
            <div class="preview-tabs">
                <button class="preview-tab active" data-view="render">2D</button>
                <button class="preview-tab" data-view="3d">3D</button>
                <button class="preview-tab" data-view="compare">Compare</button>
                <button class="preview-tab" data-view="diff">Diff</button>
            </div>
            <div class="preview-content">
                <!-- 2D Render view -->
                <div class="preview-2d" id="view-render">
                    <div class="preview-container">
                        <canvas id="canvas"></canvas>
                    </div>
                </div>
                <!-- 3D Viewer -->
                <div class="viewer-3d" id="view-3d">
                    <div class="viewer-3d-header">
                        <h3>3D Preview</h3>
                        <div class="viewer-3d-controls">
                            <select id="renderer-mode">
                                <option value="webgl">WebGL</option>
                                <option value="canvas2d">Canvas 2D</option>
                            </select>
                            <label><input type="checkbox" id="wireframe-mode"> Wire</label>
                            <label><input type="checkbox" id="auto-rotate"> Spin</label>
                        </div>
                    </div>
                    <canvas id="canvas-3d" class="viewer-3d-canvas"></canvas>
                    <canvas id="canvas-3d-webgl" class="viewer-3d-canvas" style="display:none;"></canvas>
                    <div class="viewer-3d-info">
                        <span id="mesh-info">Drag to rotate, scroll to zoom</span>
                    </div>
                </div>
                <!-- Side-by-side comparison view -->
                <div class="comparison-container" id="view-compare" style="display:none;">
                    <div class="comparison-pane reference">
                        <div class="pane-label">Reference</div>
                        <div id="reference-placeholder" class="reference-placeholder">
                            Click "Import Ref" to load image
                        </div>
                        <img id="reference-img" style="display:none;">
                    </div>
                    <div class="comparison-pane">
                        <div class="pane-label">Rendered</div>
                        <canvas id="canvas-compare"></canvas>
                    </div>
                </div>
                <!-- Diff view -->
                <div class="preview-container" id="view-diff" style="display:none;">
                    <canvas id="canvas-diff"></canvas>
                </div>
                <div id="error-container" class="error-message"></div>
            </div>
            <div class="info-bar">
                <span id="info">-</span>
                <span id="diff-info" style="display:none;">Diff: <span id="diff-percent">-</span>%</span>
            </div>
        </div>

        <!-- Hidden inputs -->
        <input type="file" id="file-input" accept="image/png,image/jpeg,image/gif,image/webp">
    </div>

    <script type="module">
        const status = document.getElementById('status');
        const editor = document.getElementById('editor');
        const canvas = document.getElementById('canvas');
        const canvasCompare = document.getElementById('canvas-compare');
        const canvasDiff = document.getElementById('canvas-diff');
        const errorContainer = document.getElementById('error-container');
        const info = document.getElementById('info');
        const diffInfo = document.getElementById('diff-info');
        const diffPercent = document.getElementById('diff-percent');
        const fileInput = document.getElementById('file-input');
        const referenceImg = document.getElementById('reference-img');
        const referencePlaceholder = document.getElementById('reference-placeholder');
        const btnClearRef = document.getElementById('btn-clear-ref');

        status.textContent = 'JS loaded...';
        console.log('Step 1: JS loaded');

        let engine = null;
        let wasmModule = null;
        let referenceDataUrl = null;
        let currentView = 'render';
        let lastRenderedDataUrl = null;

        const EXAMPLES = {
            simple: `Frame:
  width: 200px
  height: 100px
  fill: #4a90d9
  corner-radius: 8px`,
            nested: `Frame:
  width: 300px
  height: 200px
  fill: #2d2d44
  corner-radius: 12px

  Frame:
    width: 120px
    height: 80px
    x: 20px
    y: 20px
    fill: #667eea

  Frame:
    width: 120px
    height: 80px
    x: 160px
    y: 100px
    fill: #764ba2
    corner-radius: 40px`,
            gradient: `Frame:
  width: 300px
  height: 200px
  fill: linear-gradient(135deg, #667eea 0%, #764ba2 100%)
  corner-radius: 16px`
        };

        // View tab handling
        document.querySelectorAll('.preview-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                currentView = tab.dataset.view;
                updateView();
            });
        });

        function updateView() {
            document.getElementById('view-render').style.display = currentView === 'render' ? 'block' : 'none';
            document.getElementById('view-3d').style.display = currentView === '3d' ? 'flex' : 'none';
            document.getElementById('view-compare').style.display = currentView === 'compare' ? 'flex' : 'none';
            document.getElementById('view-diff').style.display = currentView === 'diff' ? 'flex' : 'none';
            diffInfo.style.display = currentView === 'diff' && referenceDataUrl ? 'inline' : 'none';

            if (currentView === '3d' && meshData) {
                resizeCanvas3d();
                render3d();
            } else if (currentView !== 'render' && lastRenderedDataUrl) {
                updateComparisonViews();
            }
        }

        function updateComparisonViews() {
            if (!lastRenderedDataUrl) return;

            // Update side-by-side comparison canvas
            const img = new Image();
            img.onload = () => {
                canvasCompare.width = img.width;
                canvasCompare.height = img.height;
                canvasCompare.getContext('2d').drawImage(img, 0, 0);

                // Update diff if reference exists
                if (referenceDataUrl && currentView === 'diff') {
                    computeDiff();
                }
            };
            img.src = lastRenderedDataUrl;
        }

        function computeDiff() {
            if (!referenceDataUrl || !lastRenderedDataUrl) return;

            const refImg = new Image();
            const renderedImg = new Image();
            let loadedCount = 0;

            const onBothLoaded = () => {
                loadedCount++;
                if (loadedCount < 2) return;

                const width = Math.max(refImg.width, renderedImg.width);
                const height = Math.max(refImg.height, renderedImg.height);

                canvasDiff.width = width;
                canvasDiff.height = height;
                const ctx = canvasDiff.getContext('2d');

                // Draw reference
                const refCanvas = document.createElement('canvas');
                refCanvas.width = width;
                refCanvas.height = height;
                const refCtx = refCanvas.getContext('2d');
                refCtx.fillStyle = '#fff';
                refCtx.fillRect(0, 0, width, height);
                refCtx.drawImage(refImg, 0, 0);
                const refData = refCtx.getImageData(0, 0, width, height);

                // Draw rendered
                const renderedCanvas = document.createElement('canvas');
                renderedCanvas.width = width;
                renderedCanvas.height = height;
                const renderedCtx = renderedCanvas.getContext('2d');
                renderedCtx.fillStyle = '#fff';
                renderedCtx.fillRect(0, 0, width, height);
                renderedCtx.drawImage(renderedImg, 0, 0);
                const renderedData = renderedCtx.getImageData(0, 0, width, height);

                // Compute difference
                const diffData = ctx.createImageData(width, height);
                let diffPixels = 0;
                const totalPixels = width * height;

                for (let i = 0; i < refData.data.length; i += 4) {
                    const dr = Math.abs(refData.data[i] - renderedData.data[i]);
                    const dg = Math.abs(refData.data[i + 1] - renderedData.data[i + 1]);
                    const db = Math.abs(refData.data[i + 2] - renderedData.data[i + 2]);
                    const diff = (dr + dg + db) / 3;

                    if (diff > 5) { // Threshold for "different"
                        diffPixels++;
                        // Highlight differences in red
                        diffData.data[i] = 255;
                        diffData.data[i + 1] = 0;
                        diffData.data[i + 2] = 0;
                        diffData.data[i + 3] = Math.min(255, diff * 3);
                    } else {
                        // Show original (dimmed)
                        diffData.data[i] = renderedData.data[i];
                        diffData.data[i + 1] = renderedData.data[i + 1];
                        diffData.data[i + 2] = renderedData.data[i + 2];
                        diffData.data[i + 3] = 128;
                    }
                }

                ctx.putImageData(diffData, 0, 0);

                const diffPercentage = ((diffPixels / totalPixels) * 100).toFixed(2);
                diffPercent.textContent = diffPercentage;
                diffInfo.style.display = 'inline';
            };

            refImg.onload = onBothLoaded;
            renderedImg.onload = onBothLoaded;
            refImg.src = referenceDataUrl;
            renderedImg.src = lastRenderedDataUrl;
        }

        // Import reference button - imports image and generates starter code
        document.getElementById('btn-import').addEventListener('click', () => {
            fileInput.click();
        });

        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                // Read file as both DataURL (for display) and ArrayBuffer (for WASM)
                const [dataUrl, arrayBuffer] = await Promise.all([
                    readFileAsDataUrl(file),
                    file.arrayBuffer()
                ]);

                referenceDataUrl = dataUrl;
                referenceImg.src = referenceDataUrl;
                referenceImg.style.display = 'block';
                referencePlaceholder.style.display = 'none';
                btnClearRef.style.display = 'inline-block';

                // Analyze image using Rust WASM analyzer
                if (wasmModule) {
                    status.textContent = 'Analyzing image...';
                    const imageBytes = new Uint8Array(arrayBuffer);
                    try {
                        const seedCode = wasmModule.analyzeImage(imageBytes);
                        editor.value = seedCode;
                        status.textContent = 'Ready';
                        status.classList.remove('error');
                        status.classList.add('ready');
                    } catch (analyzeError) {
                        console.error('Analysis error:', analyzeError);
                        // Fall back to simple JS-based generation
                        const img = new Image();
                        img.onload = () => {
                            editor.value = generateStarterCode(img);
                            doRender();
                            document.querySelector('[data-view="compare"]').click();
                        };
                        img.src = dataUrl;
                        return;
                    }
                }

                // Auto-render to show comparison
                doRender();

                // Switch to side-by-side view for comparison
                document.querySelector('[data-view="compare"]').click();
            } catch (err) {
                console.error('File read error:', err);
                alert('Failed to read file: ' + err.message);
            }
            fileInput.value = ''; // Reset for re-selecting same file
        });

        function readFileAsDataUrl(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsDataURL(file);
            });
        }

        // Generate starter Seed code from an image
        function generateStarterCode(img) {
            const origWidth = img.width;
            const origHeight = img.height;

            // Limit render size to prevent browser hang
            const MAX_SIZE = 400;
            const scale = Math.min(1, MAX_SIZE / Math.max(origWidth, origHeight));
            const width = Math.round(origWidth * scale);
            const height = Math.round(origHeight * scale);

            // Create a smaller canvas for sampling
            const sampleCanvas = document.createElement('canvas');
            const sampleSize = Math.min(100, Math.min(origWidth, origHeight));
            const sampleScale = sampleSize / Math.max(origWidth, origHeight);
            sampleCanvas.width = Math.round(origWidth * sampleScale);
            sampleCanvas.height = Math.round(origHeight * sampleScale);
            const ctx = sampleCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0, sampleCanvas.width, sampleCanvas.height);

            // Sample colors from the scaled-down image
            const colors = sampleImageColors(ctx, sampleCanvas.width, sampleCanvas.height, scale / sampleScale);

            // Generate simple Seed code template
            let code = `Frame:\n`;
            code += `  width: ${width}px\n`;
            code += `  height: ${height}px\n`;
            code += `  fill: ${colors.background}\n`;

            return code;
        }

        // Sample colors from image
        function sampleImageColors(ctx, width, height, outputScale) {
            // Get all pixel data at once (more efficient)
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;

            // Get background color from corners
            const getPixel = (x, y) => {
                const i = (y * width + x) * 4;
                return { r: data[i], g: data[i+1], b: data[i+2] };
            };

            const corners = [
                getPixel(0, 0),
                getPixel(width-1, 0),
                getPixel(0, height-1),
                getPixel(width-1, height-1)
            ];

            let r = 0, g = 0, b = 0;
            corners.forEach(c => { r += c.r; g += c.g; b += c.b; });
            const bgColor = { r: Math.round(r/4), g: Math.round(g/4), b: Math.round(b/4) };

            return {
                background: rgbToHex(bgColor),
                regions: []
            };
        }

        function rgbToHex(c) {
            return '#' + [c.r, c.g, c.b].map(x => x.toString(16).padStart(2, '0')).join('');
        }

        // Clear reference button
        btnClearRef.addEventListener('click', () => {
            referenceDataUrl = null;
            referenceImg.src = '';
            referenceImg.style.display = 'none';
            referencePlaceholder.style.display = 'block';
            btnClearRef.style.display = 'none';
            diffInfo.style.display = 'none';
        });

        // Event listeners
        document.getElementById('btn-render').addEventListener('click', doRender);

        document.getElementById('btn-svg').addEventListener('click', () => {
            if (!engine) { alert('Engine not ready'); return; }
            try {
                const svg = engine.exportSvg();
                download('seed.svg', svg, 'image/svg+xml');
            } catch (e) { alert('SVG export error: ' + e.message); }
        });

        document.getElementById('btn-png').addEventListener('click', () => {
            if (!engine) { alert('Engine not ready'); return; }
            try {
                engine.parse(editor.value);
                engine.layout();
                const pngData = engine.exportPng();
                const blob = new Blob([pngData], { type: 'image/png' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'seed.png';
                a.click();
                URL.revokeObjectURL(url);
            } catch (e) { alert('PNG export error: ' + e.message); }
        });

        document.getElementById('examples').addEventListener('change', (e) => {
            const example = EXAMPLES[e.target.value];
            if (example) {
                editor.value = example;
                doRender();
            }
            e.target.value = '';
        });

        editor.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'Enter') {
                e.preventDefault();
                doRender();
            }
        });

        console.log('Step 2: Event listeners attached');

        function doRender() {
            console.log('doRender called');
            if (!engine) { alert('Engine not ready'); return; }
            try {
                errorContainer.style.display = 'none';
                console.log('Parsing:', editor.value);
                engine.parse(editor.value);
                console.log('Parsed, computing layout...');
                engine.layout();
                console.log('Layout done, exporting PNG...');
                const pngData = engine.exportPng();
                console.log('PNG exported, size:', pngData.length);

                // Create data URL
                let binary = '';
                const chunkSize = 8192;
                for (let i = 0; i < pngData.length; i += chunkSize) {
                    const chunk = pngData.slice(i, i + chunkSize);
                    binary += String.fromCharCode.apply(null, chunk);
                }
                const base64 = btoa(binary);
                lastRenderedDataUrl = 'data:image/png;base64,' + base64;

                const blob = new Blob([pngData], { type: 'image/png' });
                const url = URL.createObjectURL(blob);

                const img = new Image();
                img.onload = () => {
                    console.log('Image loaded:', img.width, 'x', img.height);
                    canvas.width = img.width;
                    canvas.height = img.height;
                    canvas.getContext('2d').drawImage(img, 0, 0);
                    URL.revokeObjectURL(url);
                    info.textContent = img.width + ' x ' + img.height;

                    // Update comparison views if not in render-only mode
                    if (currentView !== 'render') {
                        updateComparisonViews();
                    }
                };
                img.onerror = (e) => {
                    console.error('Image load error:', e);
                    // Try data URL as fallback
                    const img2 = new Image();
                    img2.onload = () => {
                        canvas.width = img2.width;
                        canvas.height = img2.height;
                        canvas.getContext('2d').drawImage(img2, 0, 0);
                        info.textContent = img2.width + ' x ' + img2.height;
                        if (currentView !== 'render') {
                            updateComparisonViews();
                        }
                    };
                    img2.src = lastRenderedDataUrl;
                };
                img.src = url;
            } catch (e) {
                errorContainer.textContent = e.message;
                errorContainer.style.display = 'block';
            }
        }

        function download(filename, content, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ============================================
        // File Converter Functionality
        // ============================================

        let fileConverter = null;
        let currentFileData = null;
        let currentScene = null;
        let converterModule = null;

        // Set up file converter UI immediately (before WASM loads)
        const dropZone = document.getElementById('drop-zone');
        const fileInput3D = document.getElementById('file-input-3d');
        const fileInfo = document.getElementById('file-info');
        const fileName = document.getElementById('file-name');
        const fileFormat = document.getElementById('file-format');
        const exportFormat = document.getElementById('export-format');
        const btnConvert = document.getElementById('btn-convert');
        const convertError = document.getElementById('convert-error');

        // Load WASM
        try {
            console.log('Step 3: Loading WASM...');
            const module = await import('../pkg/seed_wasm.js');
            console.log('Step 4: Module loaded');

            await module.default();
            console.log('Step 5: WASM initialized');

            wasmModule = module;
            engine = new module.SeedEngine();
            const version = module.getVersion();
            console.log('Step 6: Ready, version:', version);

            status.textContent = 'Ready (v' + version + ')';
            status.classList.add('ready');

            doRender();

            // Initialize file converter
            initFileConverter(module);
        } catch (e) {
            console.error('Load error:', e);
            status.textContent = 'Error: ' + e.message;
            status.classList.add('error');
        }

        // Prevent browser from opening dropped files
        document.addEventListener('dragover', (e) => e.preventDefault());
        document.addEventListener('drop', (e) => e.preventDefault());

        // Click to browse - set up immediately
        dropZone.addEventListener('click', (e) => {
            e.stopPropagation();
            fileInput3D.click();
        });

        // Drag and drop - set up immediately
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.add('dragover');
        });
        dropZone.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
        });
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropZone.classList.remove('dragover');
            const file = e.dataTransfer.files[0];
            if (file) handleFileImport(file);
        });

        // File input change
        fileInput3D.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleFileImport(file);
            fileInput3D.value = '';
        });

        // Export format change
        exportFormat.addEventListener('change', () => {
            btnConvert.disabled = !currentScene || !exportFormat.value;
        });

        // Convert button
        btnConvert.addEventListener('click', doConvert);

        function initFileConverter(module) {
            converterModule = module;
            fileConverter = new module.FileConverter();

            // Log supported formats
            const readFormats = module.getSupportedReadFormats();
            const writeFormats = module.getSupportedWriteFormats();
            console.log('Supported read formats:', readFormats);
            console.log('Supported write formats:', writeFormats);
        }

        async function handleFileImport(file) {
            if (!fileConverter || !converterModule) {
                convertError.textContent = 'WASM not loaded yet. Please wait...';
                convertError.style.display = 'block';
                return;
            }

            status.textContent = 'Reading...';
            status.classList.remove('ready', 'error');
            convertError.style.display = 'none';

            try {
                const arrayBuffer = await file.arrayBuffer();
                currentFileData = new Uint8Array(arrayBuffer);

                // Debug: show first 100 bytes
                const firstBytes = new TextDecoder().decode(currentFileData.slice(0, 100));
                console.log('File first 100 bytes:', firstBytes);
                console.log('File size:', currentFileData.length, 'bytes');

                // Update file info
                fileName.textContent = file.name;
                fileSize.textContent = formatFileSize(file.size);

                // Detect format
                console.log('Attempting format detection...');
                const detectedFormat = converterModule.detectFileFormat(currentFileData);
                console.log('Detected format:', detectedFormat);
                if (detectedFormat) {
                    fileFormat.textContent = detectedFormat.toUpperCase();
                    fileFormat.className = 'format-badge format-' + detectedFormat;
                } else {
                    fileFormat.textContent = 'Unknown';
                    fileFormat.className = 'format-badge';
                }

                fileInfo.classList.add('visible');

                // Read and get stats
                status.textContent = 'Parsing...';
                currentScene = fileConverter.read(currentFileData);

                // Update scene stats
                updateSceneStats(currentScene);

                status.textContent = 'Ready';
                status.classList.add('ready');
                btnConvert.disabled = !exportFormat.value;

            } catch (err) {
                console.error('Import error:', err);
                status.textContent = 'Error';
                status.classList.add('error');
                convertError.textContent = err.message || 'Failed to read file';
                convertError.style.display = 'block';
                currentScene = null;
                currentFileData = null;
                btnConvert.disabled = true;
            }
        }

        function doConvert() {
            if (!fileConverter || !currentScene || !exportFormat.value) return;

            status.textContent = 'Converting...';
            status.classList.remove('ready', 'error');
            convertError.style.display = 'none';

            try {
                const format = exportFormat.value;
                const outputData = fileConverter.write(currentScene, format);

                // Determine file extension and mime type
                const extensions = {
                    seed: '.seed',
                    gltf: '.glb',
                    step: '.step',
                    usd: '.usda'
                };
                const mimeTypes = {
                    seed: 'text/plain',
                    gltf: 'model/gltf-binary',
                    step: 'application/step',
                    usd: 'text/plain'
                };

                const ext = extensions[format] || '.bin';
                const mime = mimeTypes[format] || 'application/octet-stream';
                const baseName = fileName.textContent.replace(/\.[^.]+$/, '');

                // Download
                const blob = new Blob([outputData], { type: mime });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = baseName + ext;
                a.click();
                URL.revokeObjectURL(url);

                status.textContent = 'Ready';
                status.classList.add('ready');

            } catch (err) {
                console.error('Convert error:', err);
                status.textContent = 'Error';
                status.classList.add('error');
                convertError.textContent = err.message || 'Conversion failed';
                convertError.style.display = 'block';
            }
        }

        function updateSceneStats(scene) {
            document.getElementById('stat-nodes').textContent = scene.nodes?.length || 0;
            document.getElementById('stat-geometries').textContent = scene.geometries?.length || 0;
            document.getElementById('stat-materials').textContent = scene.materials?.length || 0;
        }

        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(2) + ' MB';
        }

        // ============================================
        // 3D Viewer (WebGL + Canvas 2D fallback)
        // ============================================

        const canvas3d = document.getElementById('canvas-3d');
        const canvas3dWebGL = document.getElementById('canvas-3d-webgl');
        const ctx3d = canvas3d.getContext('2d');
        const viewer3d = document.getElementById('viewer-3d');
        const meshInfo = document.getElementById('mesh-info');
        const wireframeMode = document.getElementById('wireframe-mode');
        const autoRotate = document.getElementById('auto-rotate');
        const rendererMode = document.getElementById('renderer-mode');

        let meshData = null;
        let rotationX = -0.5;
        let rotationY = 0.3;
        let zoom = 1.0;
        let isDragging3d = false;
        let lastMouseX = 0;
        let lastMouseY = 0;
        let animationId = null;

        // WebGL state
        let gl = null;
        let glProgram = null;
        let glProgramWireframe = null;
        let glPositionBuffer = null;
        let glNormalBuffer = null;
        let glIndexBuffer = null;
        let glWireframeIndexBuffer = null;
        let glVertexCount = 0;
        let glWireframeIndexCount = 0;
        let webglAvailable = false;

        // WebGL shaders
        const vertexShaderSource = `
            attribute vec3 aPosition;
            attribute vec3 aNormal;
            uniform mat4 uModelView;
            uniform mat4 uProjection;
            uniform mat3 uNormalMatrix;
            varying vec3 vNormal;
            varying vec3 vPosition;
            void main() {
                vec4 mvPosition = uModelView * vec4(aPosition, 1.0);
                gl_Position = uProjection * mvPosition;
                vPosition = mvPosition.xyz;
                vNormal = uNormalMatrix * aNormal;
            }
        `;

        const fragmentShaderSource = `
            precision mediump float;
            varying vec3 vNormal;
            varying vec3 vPosition;
            uniform vec3 uLightDir;
            uniform vec3 uBaseColor;
            uniform bool uWireframe;
            void main() {
                if (uWireframe) {
                    gl_FragColor = vec4(0.4, 0.5, 0.92, 1.0);
                } else {
                    vec3 normal = normalize(vNormal);
                    float diffuse = max(dot(normal, uLightDir), 0.0);
                    float ambient = 0.3;
                    vec3 color = uBaseColor * (ambient + diffuse * 0.7);
                    gl_FragColor = vec4(color, 1.0);
                }
            }
        `;

        // Initialize WebGL
        function initWebGL() {
            gl = canvas3dWebGL.getContext('webgl', { antialias: true, alpha: false });
            if (!gl) {
                console.warn('WebGL not available, using Canvas 2D');
                rendererMode.value = 'canvas2d';
                rendererMode.querySelector('option[value="webgl"]').disabled = true;
                return false;
            }

            // Compile shaders
            const vs = gl.createShader(gl.VERTEX_SHADER);
            gl.shaderSource(vs, vertexShaderSource);
            gl.compileShader(vs);
            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) {
                console.error('Vertex shader error:', gl.getShaderInfoLog(vs));
                return false;
            }

            const fs = gl.createShader(gl.FRAGMENT_SHADER);
            gl.shaderSource(fs, fragmentShaderSource);
            gl.compileShader(fs);
            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) {
                console.error('Fragment shader error:', gl.getShaderInfoLog(fs));
                return false;
            }

            // Link program
            glProgram = gl.createProgram();
            gl.attachShader(glProgram, vs);
            gl.attachShader(glProgram, fs);
            gl.linkProgram(glProgram);
            if (!gl.getProgramParameter(glProgram, gl.LINK_STATUS)) {
                console.error('Program link error:', gl.getProgramInfoLog(glProgram));
                return false;
            }

            // Create buffers
            glPositionBuffer = gl.createBuffer();
            glNormalBuffer = gl.createBuffer();
            glIndexBuffer = gl.createBuffer();
            glWireframeIndexBuffer = gl.createBuffer();

            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);
            gl.cullFace(gl.BACK);
            gl.clearColor(0.04, 0.04, 0.08, 1.0);

            webglAvailable = true;
            console.log('WebGL initialized successfully');
            return true;
        }

        // Upload mesh to GPU
        function uploadMeshToGPU() {
            if (!gl || !meshData) return;

            const positions = meshData.positions;
            const indices = meshData.indices;

            // Compute normals
            const normals = new Float32Array(positions.length);
            for (let i = 0; i < indices.length; i += 3) {
                const i0 = indices[i], i1 = indices[i + 1], i2 = indices[i + 2];
                const p0 = [positions[i0 * 3], positions[i0 * 3 + 1], positions[i0 * 3 + 2]];
                const p1 = [positions[i1 * 3], positions[i1 * 3 + 1], positions[i1 * 3 + 2]];
                const p2 = [positions[i2 * 3], positions[i2 * 3 + 1], positions[i2 * 3 + 2]];

                const ax = p1[0] - p0[0], ay = p1[1] - p0[1], az = p1[2] - p0[2];
                const bx = p2[0] - p0[0], by = p2[1] - p0[1], bz = p2[2] - p0[2];
                const nx = ay * bz - az * by;
                const ny = az * bx - ax * bz;
                const nz = ax * by - ay * bx;

                for (const idx of [i0, i1, i2]) {
                    normals[idx * 3] += nx;
                    normals[idx * 3 + 1] += ny;
                    normals[idx * 3 + 2] += nz;
                }
            }

            // Normalize
            for (let i = 0; i < normals.length; i += 3) {
                const len = Math.sqrt(normals[i] ** 2 + normals[i + 1] ** 2 + normals[i + 2] ** 2);
                if (len > 0) {
                    normals[i] /= len;
                    normals[i + 1] /= len;
                    normals[i + 2] /= len;
                }
            }

            // Upload position buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, glPositionBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);

            // Upload normal buffer
            gl.bindBuffer(gl.ARRAY_BUFFER, glNormalBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);

            // Upload index buffer
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(indices), gl.STATIC_DRAW);
            glVertexCount = indices.length;

            // Create wireframe indices (line pairs for each triangle edge)
            const wireframeIndices = [];
            const edgeSet = new Set();
            for (let i = 0; i < indices.length; i += 3) {
                const edges = [
                    [indices[i], indices[i + 1]],
                    [indices[i + 1], indices[i + 2]],
                    [indices[i + 2], indices[i]]
                ];
                for (const [a, b] of edges) {
                    const key = a < b ? `${a}-${b}` : `${b}-${a}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        wireframeIndices.push(a, b);
                    }
                }
            }
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glWireframeIndexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array(wireframeIndices), gl.STATIC_DRAW);
            glWireframeIndexCount = wireframeIndices.length;

            // Enable OES_element_index_uint for large meshes
            gl.getExtension('OES_element_index_uint');
        }

        // Matrix utilities
        function mat4Perspective(fov, aspect, near, far) {
            const f = 1.0 / Math.tan(fov / 2);
            return new Float32Array([
                f / aspect, 0, 0, 0,
                0, f, 0, 0,
                0, 0, (far + near) / (near - far), -1,
                0, 0, (2 * far * near) / (near - far), 0
            ]);
        }

        function mat4Identity() {
            return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
        }

        function mat4Multiply(a, b) {
            const out = new Float32Array(16);
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    out[i * 4 + j] = a[i * 4] * b[j] + a[i * 4 + 1] * b[4 + j] +
                                     a[i * 4 + 2] * b[8 + j] + a[i * 4 + 3] * b[12 + j];
                }
            }
            return out;
        }

        function mat4RotateX(m, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            const r = new Float32Array([1,0,0,0, 0,c,s,0, 0,-s,c,0, 0,0,0,1]);
            return mat4Multiply(m, r);
        }

        function mat4RotateY(m, angle) {
            const c = Math.cos(angle), s = Math.sin(angle);
            const r = new Float32Array([c,0,-s,0, 0,1,0,0, s,0,c,0, 0,0,0,1]);
            return mat4Multiply(m, r);
        }

        function mat4Translate(m, x, y, z) {
            const t = new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]);
            return mat4Multiply(m, t);
        }

        function mat4Scale(m, s) {
            const sc = new Float32Array([s,0,0,0, 0,s,0,0, 0,0,s,0, 0,0,0,1]);
            return mat4Multiply(m, sc);
        }

        function mat3FromMat4(m) {
            return new Float32Array([m[0],m[1],m[2], m[4],m[5],m[6], m[8],m[9],m[10]]);
        }

        // WebGL render
        function renderWebGL() {
            if (!gl || !meshData || !webglAvailable) return;

            const w = canvas3dWebGL.width;
            const h = canvas3dWebGL.height;
            gl.viewport(0, 0, w, h);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

            gl.useProgram(glProgram);

            // Compute model-view matrix
            const min = meshData.bounds_min;
            const max = meshData.bounds_max;
            const cx = (min[0] + max[0]) / 2;
            const cy = (min[1] + max[1]) / 2;
            const cz = (min[2] + max[2]) / 2;
            const size = Math.max(max[0] - min[0], max[1] - min[1], max[2] - min[2]);
            const scale = 2.0 / size * zoom;

            let mv = mat4Identity();
            mv = mat4Translate(mv, 0, 0, -3);
            mv = mat4RotateX(mv, rotationX);
            mv = mat4RotateY(mv, rotationY);
            mv = mat4Scale(mv, scale);
            mv = mat4Translate(mv, -cx, -cy, -cz);

            const proj = mat4Perspective(Math.PI / 4, w / h, 0.1, 100);
            const normalMatrix = mat3FromMat4(mv);

            // Set uniforms
            gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'uModelView'), false, mv);
            gl.uniformMatrix4fv(gl.getUniformLocation(glProgram, 'uProjection'), false, proj);
            gl.uniformMatrix3fv(gl.getUniformLocation(glProgram, 'uNormalMatrix'), false, normalMatrix);
            gl.uniform3fv(gl.getUniformLocation(glProgram, 'uLightDir'), [0.5, 0.7, 1.0]);
            gl.uniform3fv(gl.getUniformLocation(glProgram, 'uBaseColor'), [0.4, 0.5, 0.9]);
            gl.uniform1i(gl.getUniformLocation(glProgram, 'uWireframe'), wireframeMode.checked ? 1 : 0);

            // Bind attributes
            const aPosition = gl.getAttribLocation(glProgram, 'aPosition');
            gl.bindBuffer(gl.ARRAY_BUFFER, glPositionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);

            const aNormal = gl.getAttribLocation(glProgram, 'aNormal');
            gl.bindBuffer(gl.ARRAY_BUFFER, glNormalBuffer);
            gl.enableVertexAttribArray(aNormal);
            gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);

            if (wireframeMode.checked) {
                gl.disable(gl.CULL_FACE);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glWireframeIndexBuffer);
                gl.drawElements(gl.LINES, glWireframeIndexCount, gl.UNSIGNED_INT, 0);
            } else {
                gl.enable(gl.CULL_FACE);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, glIndexBuffer);
                gl.drawElements(gl.TRIANGLES, glVertexCount, gl.UNSIGNED_INT, 0);
            }

            // Auto-rotate
            if (autoRotate.checked) {
                rotationY += 0.01;
                animationId = requestAnimationFrame(render3d);
            }
        }

        // Canvas 2D render (fallback)
        function renderCanvas2D() {
            if (!meshData || !meshData.positions.length) return;

            const w = canvas3d.width / window.devicePixelRatio;
            const h = canvas3d.height / window.devicePixelRatio;

            ctx3d.fillStyle = '#0a0a15';
            ctx3d.fillRect(0, 0, w, h);

            const min = meshData.bounds_min;
            const max = meshData.bounds_max;
            const cx = (min[0] + max[0]) / 2;
            const cy = (min[1] + max[1]) / 2;
            const cz = (min[2] + max[2]) / 2;
            const size = Math.max(max[0] - min[0], max[1] - min[1], max[2] - min[2]);
            const scale = (Math.min(w, h) * 0.4 * zoom) / size;

            const cosX = Math.cos(rotationX), sinX = Math.sin(rotationX);
            const cosY = Math.cos(rotationY), sinY = Math.sin(rotationY);

            function project(x, y, z) {
                x -= cx; y -= cy; z -= cz;
                const x1 = x * cosY - z * sinY;
                const z1 = x * sinY + z * cosY;
                const y1 = y * cosX - z1 * sinX;
                const z2 = y * sinX + z1 * cosX;
                return [w/2 + x1 * scale, h/2 - y1 * scale, z2];
            }

            const positions = meshData.positions;
            const indices = meshData.indices;

            if (wireframeMode.checked) {
                ctx3d.strokeStyle = '#667eea';
                ctx3d.lineWidth = 0.5;
                ctx3d.beginPath();
                for (let i = 0; i < indices.length; i += 3) {
                    const i0 = indices[i] * 3;
                    const i1 = indices[i + 1] * 3;
                    const i2 = indices[i + 2] * 3;
                    const p0 = project(positions[i0], positions[i0 + 1], positions[i0 + 2]);
                    const p1 = project(positions[i1], positions[i1 + 1], positions[i1 + 2]);
                    const p2 = project(positions[i2], positions[i2 + 1], positions[i2 + 2]);
                    ctx3d.moveTo(p0[0], p0[1]);
                    ctx3d.lineTo(p1[0], p1[1]);
                    ctx3d.lineTo(p2[0], p2[1]);
                    ctx3d.lineTo(p0[0], p0[1]);
                }
                ctx3d.stroke();
            } else {
                const triangles = [];
                for (let i = 0; i < indices.length; i += 3) {
                    const i0 = indices[i] * 3;
                    const i1 = indices[i + 1] * 3;
                    const i2 = indices[i + 2] * 3;
                    const p0 = project(positions[i0], positions[i0 + 1], positions[i0 + 2]);
                    const p1 = project(positions[i1], positions[i1 + 1], positions[i1 + 2]);
                    const p2 = project(positions[i2], positions[i2 + 1], positions[i2 + 2]);
                    const ax = p1[0] - p0[0], ay = p1[1] - p0[1];
                    const bx = p2[0] - p0[0], by = p2[1] - p0[1];
                    const nz = ax * by - ay * bx;
                    if (nz > 0) continue;
                    const avgZ = (p0[2] + p1[2] + p2[2]) / 3;
                    triangles.push({ p0, p1, p2, avgZ, nz });
                }
                triangles.sort((a, b) => a.avgZ - b.avgZ);
                for (const tri of triangles) {
                    const brightness = Math.min(255, Math.max(50, 150 - tri.nz * 0.1));
                    ctx3d.fillStyle = `rgb(${brightness * 0.4}, ${brightness * 0.5}, ${brightness})`;
                    ctx3d.beginPath();
                    ctx3d.moveTo(tri.p0[0], tri.p0[1]);
                    ctx3d.lineTo(tri.p1[0], tri.p1[1]);
                    ctx3d.lineTo(tri.p2[0], tri.p2[1]);
                    ctx3d.closePath();
                    ctx3d.fill();
                }
            }

            if (autoRotate.checked) {
                rotationY += 0.01;
                animationId = requestAnimationFrame(render3d);
            }
        }

        // Main render dispatcher
        function render3d() {
            if (!meshData) return;
            if (rendererMode.value === 'webgl' && webglAvailable) {
                renderWebGL();
            } else {
                renderCanvas2D();
            }
        }

        // Load and render mesh
        async function loadMeshForViewer() {
            if (!fileConverter || !currentFileData) return;

            try {
                meshData = fileConverter.getMeshData(currentFileData);
                if (meshData && meshData.positions.length > 0) {
                    const vertCount = meshData.positions.length / 3;
                    const triCount = meshData.indices.length / 3;
                    meshInfo.textContent = `${vertCount.toLocaleString()} vertices, ${triCount.toLocaleString()} triangles`;

                    // Switch to 3D tab
                    document.querySelectorAll('.preview-tab').forEach(t => t.classList.remove('active'));
                    document.querySelector('[data-view="3d"]').classList.add('active');
                    currentView = '3d';
                    updateView();

                    resizeCanvas3d();

                    // Initialize WebGL if not done
                    if (!gl) initWebGL();

                    // Upload to GPU
                    if (webglAvailable) {
                        uploadMeshToGPU();
                    }

                    updateRendererVisibility();
                    render3d();
                }
            } catch (err) {
                console.error('Mesh load error:', err);
            }
        }

        function resizeCanvas3d() {
            const rect = canvas3d.getBoundingClientRect();
            const dpr = window.devicePixelRatio;

            // Canvas 2D
            canvas3d.width = rect.width * dpr;
            canvas3d.height = rect.height * dpr;
            ctx3d.setTransform(1, 0, 0, 1, 0, 0);
            ctx3d.scale(dpr, dpr);

            // WebGL canvas
            canvas3dWebGL.width = rect.width * dpr;
            canvas3dWebGL.height = rect.height * dpr;
        }

        function updateRendererVisibility() {
            const useWebGL = rendererMode.value === 'webgl' && webglAvailable;
            canvas3d.style.display = useWebGL ? 'none' : 'block';
            canvas3dWebGL.style.display = useWebGL ? 'block' : 'none';
        }

        // Get active canvas for mouse events
        function getActiveCanvas() {
            return rendererMode.value === 'webgl' && webglAvailable ? canvas3dWebGL : canvas3d;
        }

        // Mouse controls for both canvases
        function setupMouseControls(canvasEl) {
            canvasEl.addEventListener('mousedown', (e) => {
                isDragging3d = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                if (animationId) cancelAnimationFrame(animationId);
            });

            canvasEl.addEventListener('mousemove', (e) => {
                if (!isDragging3d) return;
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                rotationY += dx * 0.01;
                rotationX += dy * 0.01;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                render3d();
            });

            canvasEl.addEventListener('mouseup', () => { isDragging3d = false; });
            canvasEl.addEventListener('mouseleave', () => { isDragging3d = false; });

            canvasEl.addEventListener('wheel', (e) => {
                e.preventDefault();
                zoom *= e.deltaY > 0 ? 0.9 : 1.1;
                zoom = Math.max(0.1, Math.min(10, zoom));
                render3d();
            });
        }

        setupMouseControls(canvas3d);
        setupMouseControls(canvas3dWebGL);

        wireframeMode.addEventListener('change', render3d);
        autoRotate.addEventListener('change', () => {
            if (autoRotate.checked) render3d();
        });
        rendererMode.addEventListener('change', () => {
            updateRendererVisibility();
            render3d();
        });

        window.addEventListener('resize', () => {
            if (meshData) {
                resizeCanvas3d();
                render3d();
            }
        });

        // Hook into file import
        const originalHandleFileImport = handleFileImport;
        handleFileImport = async function(file) {
            await originalHandleFileImport(file);
            loadMeshForViewer();
        };
    </script>
</body>
</html>
